package impl

// 当前 handleReceiveMsg 的实现中，对于 每次收到消息都通过MQ发送完整的20条历史对话：
// 潜在的资源消耗和优化空间：
//
//虽然是“对的”，但这种模式可能带来以下几点考虑：
//
//MQ 消息体大小：如果历史记录很长（例如 20 条消息，每条消息内容也很长），MQ 消息体可能会变得很大，这会增加 MQ 的网络传输和存储负担。
//重复传输：每次新消息都传输一遍完整的历史记录，其中大部分历史是重复的。
//可能的优化方向（但不是当前阶段的改造任务，留作未来思考）：
//
//历史记录的截断策略：当前是获取 20 条，未来可以根据实际对话长度和 LLM 的上下文窗口大小进行动态调整，甚至根据消息类型（例如，排除不重要的系统消息）进行过滤。
//历史记录的压缩/摘要：对于超长的会话，可以考虑在 qmsg 或 aiadmin 侧对历史记录进行摘要或压缩，只保留关键信息。但这会增加额外处理逻辑和复杂度。
//增量式传递（复杂）：仅传递新消息，历史记录的指针或版本号，让 aiadmin 自己去查。但这会打破 qmsg 和 aiadmin 之间的异步解耦，增加 aiadmin 对 qmsg 数据库的直接依赖，通常不推荐。
//Session State (更高级的 Agent 模式)：在更成熟的 Agent 模式中，aiadmin 可以在自身维护一个对话状态（Session State），每次收到新消息时，只更新这个状态，而不是每次都从 qmsg 接收全部历史。但这需要 aiadmin 具备强大的状态管理和持久化能力，并且要处理好分布式环境下的状态一致性问题。
